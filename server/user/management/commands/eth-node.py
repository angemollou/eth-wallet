import os
import subprocess
import shutil
from time import sleep
from django.core.management.base import BaseCommand, CommandError
from django.conf import settings
import logging


TERMINAL_SIZE = shutil.get_terminal_size()
LOG_SEPARATOR = "\n{}\n".format(
    "-" * int(TERMINAL_SIZE[0] * 80 / 100)
    if TERMINAL_SIZE[0] > 80
    else TERMINAL_SIZE[0]
)
logging.basicConfig(format="[%(asctime)s]  %(name)s  %(message)s")
logger = logging.getLogger(__name__)
BASE_DIR = settings.ETH_NODE["BASE_DIR"]
CHAIN_ID = (
    11155111  # Sepolia testnet
    if settings.DEBUG
    else settings.ETH_NODE["SIGNER"]["CHAIN_ID"]
)
DATA_SUBDIR = ".ethereum"


class Command(BaseCommand):
    help = "Run a Ethereum node via docker"

    def add_arguments(self, parser):
        parser.add_argument(
            "-u",
            "--newaccount",
            action="store_true",
            help="Request a new wallet address?",
        )  # on/off flag
        parser.add_argument(
            "-w",
            "--password",
            help="A password that is at least 10 characters long",
        )
        parser.add_argument(
            "-r", "--reset", action="store_true", help="Clean volumes?"
        )  # on/off flag

    ps = dict()
    is_newaccount_required = False

    def handle(self, *args, **options):
        try:
            if options["reset"]:
                shutil.rmtree(BASE_DIR, ignore_errors=True)

            cmd = self.start_signer(*args, **options)
            self.handle_event("start", "signer", cmd)
            self.ps["signer"] = subprocess.Popen(cmd, cwd=BASE_DIR)
            # self.wait_for(self.abs_path(".ethereum/masterseed.json"))

            cmd = self.start_execution(*args, **options)
            self.handle_event("start", "execution", cmd)
            self.ps["execution"] = subprocess.Popen(cmd, cwd=BASE_DIR)
            # self.wait_for(self.abs_path(".ethereum/geth/geth.ipc"))

            # Start all dependencies then hold on until Execution client exits
            self.ps["execution"].wait()

        except Exception as e:
            logger.error("Error was not handled: %s", e)
        finally:
            self.cleanup()

    def start_execution(self, *_, **options):
        try:
            if not os.path.isdir(self.abs_path(DATA_SUBDIR)):
                os.makedirs(self.abs_path(DATA_SUBDIR))

            cmd = [
                "docker",
                "run",
                # tty enable docker logs coloring
                "-t",
                # "-d",
                "--name",
                settings.ETH_NODE["EXECUTION"]["NAME"],
                "--rm",
                "-p",
                "8545:%d" % (settings.ETH_NODE["EXECUTION"]["HTTP"] or 8545),
                "-p",
                "30303:%d" % (settings.ETH_NODE["EXECUTION"]["TCP"] or 30303),
                "-v",
                "%s:/root/" % BASE_DIR,
                # Constraint: make be generated by SIGNER
                # "-v",
                # "%s:/root/.ethereum/keystore:ro" % self.abs_path(".ethereum/keystore"),
                # Constraint: make be created inside EXECUTION container
                # "-v",
                # "%s:/root/.ethereum/geth/geth.ipc"
                # % self.abs_path(".ethereum/geth/geth.ipc"),
                settings.ETH_NODE["EXECUTION"]["IMAGE"],
                "--http.addr",
                "0.0.0.0",
                "--keystore",
                "/root/.ethereum/keystore",
                "--ipcpath",
                "/root/.ethereum/geth/geth.ipc",
            ]
            return cmd
        except Exception as e:
            self.handle_error("execution", e)

    def start_signer(self, *_, **options):
        try:
            self.is_newaccount_required = options["reset"] or options["newaccount"]
            if options["newaccount"]:
                shutil.rmtree(self.abs_path(), ignore_errors=True)
            if not os.path.isdir(self.abs_path()):
                if options["password"]:
                    self.touch(
                        self.abs_path(DATA_SUBDIR, "password"), options["password"]
                    )
                    self.is_newaccount_required = True
                else:
                    raise ValueError("-w, --password is required")
                os.makedirs(self.abs_path(DATA_SUBDIR, "keystore"))
                # touch(self.abs_path(DATA_SUBDIR, "run/pcscd/pcscd.comm"))

            cmd = [
                "docker",
                "run",
                # tty enable docker logs coloring
                "-t",
                # "-d",
                "--name",
                settings.ETH_NODE["SIGNER"]["NAME"],
                "--rm",
                "-p",
                "8550:%s" % (settings.ETH_NODE["SIGNER"]["HTTP"] or 8550),
                "-e",
                "DATA=/app/data",  # --configdir=$DATA
                "-e",
                "CLEF_CHAINID=%d" % CHAIN_ID,  # --chainid=$CLEF_CHAINID
                "-v",
                "%s:/app/data" % self.abs_path(DATA_SUBDIR),
                # CONSTRAINT: "$DATA"/password file is required for initialization
                # "-v",
                # "%s:/app/data/password:ro" % self.abs_path(".ethereum/password"),
                # CONSTRAINT: --keystore==="$DATA"/keystore is expected for initialization
                # "-v",
                # "%s:/app/data/keystore" % self.abs_path(".ethereum/keystore"),
                # Constraint: make be created inside EXECUTION container
                # "-v",
                # "%s:/app/data/geth/geth.ipc:rw"
                # % self.abs_path(".ethereum/geth/geth.ipc"),
                settings.ETH_NODE["SIGNER"]["IMAGE"],
                "init" if self.is_newaccount_required else "",
            ]
            subprocess.check_call(cmd, cwd=BASE_DIR)
            self.cleanup_container(settings.ETH_NODE["SIGNER"]["NAME"])
            cmd[-1] = " ".join(
                [
                    "/usr/local/bin/bee-clef",
                    "--stdio-ui",
                    "--keystore",
                    "/app/data/keystore",
                    "--ipcpath",
                    "/app/data/geth/geth.ipc",
                    "--http",
                    "--http.addr",
                    "0.0.0.0",
                    "--http.port",
                    "8550",
                    "--http.vhosts",
                    "'*'",
                    "--rules",
                    "/app/config/rules.js",
                    "--nousb",
                    "--lightkdf",
                    "--4bytedb-custom ",
                    "/app/config/4byte.json",
                    # OPTIONAL: for SmartCard (character device file)
                    # "--pcscdpath",
                    # "/app/data/run/pcscd/pcscd.comm",
                    "--auditlog",
                    "''",
                    "--loglevel",
                    "3",
                    "--signersecret",
                    "/app/data/masterseed.json",
                ]
            )

            return cmd
        except Exception as e:
            self.handle_error("Signer", e)

    def cleanup_container(self, name):
        logger.warning("CLEANUP CONTAINER  %s", name)
        try:
            found = (
                subprocess.run(
                    [
                        "docker",
                        "container",
                        "ls",
                        "-a",
                        "-f",
                        "name=%s" % name,
                    ],
                    cwd=BASE_DIR,
                    capture_output=True,
                    text=True,
                ).stdout.find(name)
                != -1
            )
            if found:
                subprocess.check_call(
                    [
                        "docker",
                        "container",
                        "stop",
                        name,
                    ],
                    cwd=BASE_DIR,
                    stderr=subprocess.DEVNULL,
                )
                subprocess.call(
                    [
                        "docker",
                        "container",
                        "rm",
                        name,
                    ],
                    cwd=BASE_DIR,
                    stderr=subprocess.DEVNULL,
                )
        except Exception as e:
            logger.warning("Clean up container - Error was not handled  %s", e)

    def wait_for(self, path):
        logger.warning("WAIT FOR  %s", path)
        keys = []
        if os.path.isfile(path):
            keys = [path]
        elif os.path.isdir(path):
            keys = list(
                map(
                    lambda item: item.path,
                    os.scandir(path),
                )
            )
        if len(keys) == 0:
            sleep(settings.ETH_NODE["WAIT_THROTTLE_TIME"])
            self.wait_for(path)
            return False
        return keys[-1]

    def cleanup(self):
        logger.warning("CLEANUP")
        if self.ps.get("signer"):
            self.handle_event("exit", "signer", self.ps["signer"])
        if self.ps.get("execution"):
            self.handle_event("exit", "execution", self.ps["execution"])

        self.cleanup_container(settings.ETH_NODE["SIGNER"]["NAME"])
        self.cleanup_container(settings.ETH_NODE["EXECUTION"]["NAME"])

    def abs_path(self, *path):
        if len(path) == 0:
            return BASE_DIR
        return os.path.join(BASE_DIR, *path)

    def handle_error(self, service="", e=Exception("Error was not properly handled")):
        if isinstance(e, subprocess.CalledProcessError):
            logger.error(
                "PROCESS ERROR - %s  %s\n%s%s",
                service.upper(),
                e,
                e.output,
                LOG_SEPARATOR,
            )
        else:
            raise e

    def handle_event(self, event, name, details=""):
        try:
            logger.warning(
                "PROCESS %s - %s  %s",
                event.upper(),
                name.upper(),
                details,
            )
        except Exception as e:
            logger.error("Event was not properly handled: %s", e)

    def touch(self, path, content=None):
        os.makedirs(os.path.dirname(path))
        if content is None:
            open(path, "a").close()
        else:
            with open(path, "w+") as fd:
                fd.write(content)

        # TODO: rm debug codes
        subprocess.call(["code", path])
        return path
